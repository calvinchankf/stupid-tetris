{"version":3,"sources":["App.js","Puzzle.js","PuzzleFactory.js","index.js"],"names":["puzzleInstance","Puzzle","shapes","shapeIdx","coordinates","anchor","this","newShapeIdx","length","newShape","q","newCoordinates","seen","shift","i","j","x","y","key","push","getRandomPuzzle","r","Math","floor","random","s","delay","ms","Promise","res","setTimeout","occupieds","App","props","componentDidMount","a","addGameEventListeners","paintBoard","puzzle","state","checkCollision","checkIfTouched","isTouched","newPuzzle","cell","fullRows","findFullRows","clearFullRows","window","confirm","location","reload","createBoard","board","temp","addEventListener","event","isCollided","rotate","setShapeIdxAndCoordinates","movePuzzle","bind","di","dj","newI","newJ","setCoordinates","b","paintPuzzleOnBoard","paintOccupiesdOnBoard","setState","split","parseInt","isFull","newOccupied","keys","Object","idx","indexOf","n","forEach","row","newKey","render","rowDivs","map","className","name","boardDiv","undefined","Component","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.65cfb33b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./App.css\";\nimport { getRandomPuzzle } from \"./PuzzleFactory\";\n\nconst delay = ms => new Promise(res => setTimeout(res, ms));\n\nlet puzzleInstance;\nlet occupieds = {};\nclass App extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {\n\t\t\tboard: this.createBoard(),\n\t\t\tpuzzle: undefined\n\t\t};\n\t}\n\n\tcomponentDidMount = async () => {\n\t\tthis.addGameEventListeners();\n\n\t\t// paint puzzle on board\n\t\tpuzzleInstance = getRandomPuzzle();\n\t\tthis.paintBoard(puzzleInstance.coordinates);\n\t\tawait delay(500);\n\n\t\t// time interval or while loop?\n\t\twhile (true) {\n\t\t\tconst { puzzle } = this.state;\n\n\t\t\tif (this.checkCollision(puzzle)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet [isTouched, newPuzzle] = this.checkIfTouched();\n\n\t\t\tif (!isTouched) {\n\t\t\t\tthis.paintBoard(newPuzzle);\n\t\t\t} else {\n\t\t\t\t// put puzzle in the hashtable\n\t\t\t\tfor (let i = 0; i < puzzle.length; i++) {\n\t\t\t\t\tconst cell = puzzle[i];\n\t\t\t\t\tconst key = `${cell[0]},${cell[1]}`;\n\t\t\t\t\toccupieds[key] = true;\n\t\t\t\t}\n\t\t\t\t// clear if necessary\n\t\t\t\tconst fullRows = this.findFullRows();\n\t\t\t\tif (fullRows.length > 0) {\n\t\t\t\t\tawait delay(100);\n\t\t\t\t}\n\t\t\t\tthis.clearFullRows(fullRows);\n\t\t\t\t// drop a new puzzle\n\t\t\t\tpuzzleInstance = getRandomPuzzle();\n\t\t\t\tthis.paintBoard(puzzleInstance.coordinates);\n\t\t\t}\n\t\t\tawait delay(500);\n\t\t}\n\n\t\tconst c = window.confirm(\"❌❌❌ GAME OVER ❌❌❌\");\n\t\tif (c) {\n\t\t\twindow.location.reload();\n\t\t}\n\t};\n\n\tcreateBoard = () => {\n\t\tconst board = [];\n\t\tfor (let i = 0; i < 20; i++) {\n\t\t\tconst temp = [];\n\t\t\tfor (let j = 0; j < 10; j++) {\n\t\t\t\ttemp.push(0);\n\t\t\t}\n\t\t\tboard.push(temp);\n\t\t}\n\t\treturn board;\n\t};\n\n\taddGameEventListeners = () => {\n\t\twindow.addEventListener(\n\t\t\t\"keydown\",\n\t\t\tfunction(event) {\n\t\t\t\tconst key = event.key; // \"ArrowRight\", \"ArrowLeft\", \"ArrowUp\", or \"ArrowDown\"\n\t\t\t\tlet isCollided;\n\t\t\t\tlet newPuzzle;\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase \"ArrowUp\":\n\t\t\t\t\t\tconst res = puzzleInstance.rotate();\n\t\t\t\t\t\tconst shapeIdx = res[0];\n\t\t\t\t\t\tnewPuzzle = res[1];\n\t\t\t\t\t\tif (!this.checkCollision(newPuzzle)) {\n\t\t\t\t\t\t\tpuzzleInstance.setShapeIdxAndCoordinates(\n\t\t\t\t\t\t\t\tshapeIdx,\n\t\t\t\t\t\t\t\tnewPuzzle\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.paintBoard(newPuzzle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ArrowRight\":\n\t\t\t\t\t\t[isCollided, newPuzzle] = this.movePuzzle(0, 1);\n\t\t\t\t\t\tif (!isCollided) {\n\t\t\t\t\t\t\tthis.paintBoard(newPuzzle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ArrowDown\":\n\t\t\t\t\t\t[isCollided, newPuzzle] = this.movePuzzle(1, 0);\n\t\t\t\t\t\tif (!isCollided) {\n\t\t\t\t\t\t\tthis.paintBoard(newPuzzle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ArrowLeft\":\n\t\t\t\t\t\t[isCollided, newPuzzle] = this.movePuzzle(0, -1);\n\t\t\t\t\t\tif (!isCollided) {\n\t\t\t\t\t\t\tthis.paintBoard(newPuzzle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}.bind(this)\n\t\t);\n\t};\n\n\tmovePuzzle = (di, dj) => {\n\t\tconst { puzzle } = this.state;\n\t\tlet isCollided = false;\n\t\tlet newPuzzle = [];\n\t\tfor (let i = 0; i < puzzle.length; i++) {\n\t\t\tconst cell = puzzle[i];\n\t\t\tconst newI = cell[0] + di;\n\t\t\tconst newJ = cell[1] + dj;\n\t\t\tconst key = `${newI},${newJ}`;\n\t\t\tif (\n\t\t\t\tnewI < 0 ||\n\t\t\t\tnewI === 20 ||\n\t\t\t\tnewJ < 0 ||\n\t\t\t\tnewJ === 10 ||\n\t\t\t\tkey in occupieds\n\t\t\t) {\n\t\t\t\tisCollided = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewPuzzle.push([newI, newJ]);\n\t\t}\n\t\treturn [isCollided, newPuzzle];\n\t};\n\n\tcheckCollision = puzzle => {\n\t\tlet isCollided = false;\n\t\tfor (let i = 0; i < puzzle.length; i++) {\n\t\t\tconst cell = puzzle[i];\n\t\t\tconst newI = cell[0];\n\t\t\tconst newJ = cell[1];\n\t\t\tconst key = `${newI},${newJ}`;\n\t\t\tif (\n\t\t\t\tnewI < 0 ||\n\t\t\t\tnewI === 20 ||\n\t\t\t\tnewJ < 0 ||\n\t\t\t\tnewJ === 10 ||\n\t\t\t\tkey in occupieds\n\t\t\t) {\n\t\t\t\tisCollided = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn isCollided;\n\t};\n\n\tcheckIfTouched = () => {\n\t\tconst { puzzle } = this.state;\n\t\tlet isTouched = false;\n\t\tlet newPuzzle = [];\n\t\tfor (let i = 0; i < puzzle.length; i++) {\n\t\t\tconst cell = puzzle[i];\n\t\t\tconst newI = cell[0] + 1;\n\t\t\tconst key = `${newI},${cell[1]}`;\n\t\t\tif (newI === 20 || key in occupieds) {\n\t\t\t\tisTouched = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewPuzzle.push([newI, cell[1]]);\n\t\t}\n\t\treturn [isTouched, newPuzzle];\n\t};\n\n\tpaintBoard = puzzle => {\n\t\tpuzzleInstance.setCoordinates(puzzle);\n\t\tlet b = this.paintPuzzleOnBoard(puzzle);\n\t\tb = this.paintOccupiesdOnBoard(b);\n\t\tthis.setState({\n\t\t\tboard: b,\n\t\t\tpuzzle\n\t\t});\n\t};\n\n\tpaintPuzzleOnBoard = puzzle => {\n\t\tconst board = this.createBoard();\n\t\tfor (let i = 0; i < puzzle.length; i++) {\n\t\t\tconst cell = puzzle[i];\n\t\t\tconst x = cell[0];\n\t\t\tconst y = cell[1];\n\t\t\tboard[x][y] = 1;\n\t\t}\n\t\treturn board;\n\t};\n\n\tpaintOccupiesdOnBoard = board => {\n\t\tfor (const key in occupieds) {\n\t\t\tlet [x, y] = key.split(\",\");\n\t\t\tx = parseInt(x);\n\t\t\ty = parseInt(y);\n\t\t\tboard[x][y] = 1;\n\t\t}\n\t\treturn board;\n\t};\n\n\tfindFullRows = () => {\n\t\tconst { board } = this.state;\n\t\tconst fullRows = [];\n\t\tfor (let i = 0; i < board.length; i++) {\n\t\t\tlet isFull = true;\n\t\t\tfor (let j = 0; j < board[i].length; j++) {\n\t\t\t\tif (board[i][j] === 0) {\n\t\t\t\t\tisFull = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isFull) {\n\t\t\t\tfullRows.push(i);\n\t\t\t}\n\t\t}\n\t\treturn fullRows;\n\t};\n\n\tclearFullRows = fullRows => {\n\t\tconst newOccupied = {};\n\t\tconst keys = Object.keys(occupieds);\n\t\tfor (let idx = 0; idx < keys.length; idx++) {\n\t\t\tconst key = keys[idx];\n\t\t\tlet [i, j] = key.split(\",\");\n\t\t\ti = parseInt(i);\n\t\t\tj = parseInt(j);\n\t\t\tif (fullRows.indexOf(i) > -1) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlet n = 0;\n\t\t\t\tfullRows.forEach(row => {\n\t\t\t\t\tif (row > i) {\n\t\t\t\t\t\tn += 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (n > 0) {\n\t\t\t\t\tconst newKey = `${i + n},${j}`;\n\t\t\t\t\tnewOccupied[newKey] = true;\n\t\t\t\t} else {\n\t\t\t\t\tnewOccupied[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toccupieds = newOccupied;\n\t};\n\n\trender = () => {\n\t\tconst { board } = this.state;\n\n\t\tconst rowDivs = board.map((row, i) => {\n\t\t\treturn (\n\t\t\t\t<div key={i} className=\"row\">\n\t\t\t\t\t{row.map((cell, j) => {\n\t\t\t\t\t\tlet name = \"cell\";\n\t\t\t\t\t\tif (j === 9) {\n\t\t\t\t\t\t\tname += \" last-col\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === 19) {\n\t\t\t\t\t\t\tname += \" last-row\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cell === 1) {\n\t\t\t\t\t\t\tname += \" colored\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn <div key={j} className={name} />;\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t);\n\t\t});\n\n\t\tconst boardDiv = <div className=\"board\">{rowDivs}</div>;\n\n\t\treturn <div>{boardDiv}</div>;\n\t};\n}\n\nexport default App;\n","class Puzzle {\n\tconstructor(shapes, shapeIdx, coordinates, anchor) {\n\t\tthis.shapes = shapes;\n\t\tthis.shapeIdx = shapeIdx;\n\t\tthis.coordinates = coordinates;\n\t\tthis.anchor = anchor;\n\t}\n\trotate() {\n\t\t// BFS + hashtable\n\t\tconst newShapeIdx = (this.shapeIdx + 1) % this.shapes.length;\n\t\tconst newShape = this.shapes[newShapeIdx];\n\t\tconst q = [[...this.anchor, ...this.coordinates[0]]];\n\t\t// let i, j, x, y\n\t\tconst newCoordinates = [];\n\t\tconst seen = {};\n\t\twhile (q.length > 0) {\n\t\t\tconst [i, j, x, y] = q.shift();\n\t\t\tif (\n\t\t\t\ti < 0 ||\n\t\t\t\ti >= newShape.length ||\n\t\t\t\tj < 0 ||\n\t\t\t\tj >= newShape[0].length\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newShape[i][j] > 0) {\n\t\t\t\tconst key = `${i},${j}`;\n\t\t\t\tif (key in seen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tseen[key] = true;\n\t\t\t\tnewCoordinates.push([x, y]);\n\t\t\t\tq.push([i - 1, j, x - 1, y]);\n\t\t\t\tq.push([i + 1, j, x + 1, y]);\n\t\t\t\tq.push([i, j - 1, x, y - 1]);\n\t\t\t\tq.push([i, j + 1, x, y + 1]);\n\t\t\t}\n\t\t}\n\t\treturn [newShapeIdx, newCoordinates];\n\t}\n\tsetCoordinates(coordinates) {\n\t\tthis.coordinates = coordinates;\n\t}\n\tsetShapeIdxAndCoordinates(shapeIdx, coordinates) {\n\t\tthis.shapeIdx = shapeIdx;\n\t\tthis.coordinates = coordinates;\n\t}\n}\n\nexport default Puzzle;\n","import Puzzle from \"./Puzzle\";\n\nconst W = {\n\tshapes: [\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 1]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[0, 4],\n\t\t[0, 5],\n\t\t[1, 4],\n\t\t[1, 5]\n\t],\n\tanchor: [0, 0]\n};\n\nconst I = {\n\tshapes: [\n\t\t[\n\t\t\t[1, 1, 1, 1],\n\t\t\t[0, 0, 0, 0],\n\t\t\t[0, 0, 0, 0],\n\t\t\t[0, 0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 0, 1, 0],\n\t\t\t[0, 0, 1, 0],\n\t\t\t[0, 0, 1, 0],\n\t\t\t[0, 0, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[0, 5],\n\t\t[0, 3],\n\t\t[0, 4],\n\t\t[0, 6]\n\t],\n\tanchor: [0, 2]\n};\n\nconst T = {\n\tshapes: [\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 0, 0],\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[1, 5],\n\t\t[0, 5],\n\t\t[1, 4],\n\t\t[1, 6]\n\t],\n\tanchor: [1, 1]\n};\n\nconst Z = {\n\tshapes: [\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t\t[0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 0, 1],\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[1, 5],\n\t\t[0, 5],\n\t\t[0, 4],\n\t\t[1, 6]\n\t],\n\tanchor: [1, 1]\n};\n\nconst S = {\n\tshapes: [\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[1, 1, 0],\n\t\t\t[0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[1, 0, 0],\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[1, 5],\n\t\t[0, 5],\n\t\t[0, 6],\n\t\t[1, 4]\n\t],\n\tanchor: [1, 1]\n};\n\nconst L = {\n\tshapes: [\n\t\t[\n\t\t\t[1, 0, 0],\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 0, 0],\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 1]\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[1, 5],\n\t\t[1, 4],\n\t\t[1, 6],\n\t\t[0, 4]\n\t],\n\tanchor: [1, 1]\n};\n\nconst RL = {\n\tshapes: [\n\t\t[\n\t\t\t[0, 0, 1],\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1]\n\t\t],\n\t\t[\n\t\t\t[0, 0, 0],\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 0]\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0]\n\t\t]\n\t],\n\tshapeIdx: 0,\n\tcoordinates: [\n\t\t[1, 5],\n\t\t[1, 4],\n\t\t[1, 6],\n\t\t[0, 6]\n\t],\n\tanchor: [1, 1]\n};\n\nconst shapes = [W, I, T, Z, S, L, RL];\n\nconst getRandomPuzzle = () => {\n\tconst r = Math.floor(Math.random() * shapes.length);\n\tconst s = shapes[r];\n\treturn new Puzzle(s.shapes, s.shapeIdx, s.coordinates, s.anchor);\n};\n\nexport { getRandomPuzzle };\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}